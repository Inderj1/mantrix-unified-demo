import React, { useState, useRef, useEffect } from 'react';
import {
  Box,
  Paper,
  TextField,
  Button,
  Typography,
  Avatar,
  Stack,
  IconButton,
  CircularProgress,
  Alert,
  Divider,
  Chip,
  Accordion,
  AccordionSummary,
  AccordionDetails,
} from '@mui/material';
import {
  Send as SendIcon,
  SmartToy as AIIcon,
  Person as PersonIcon,
  ContentCopy as CopyIcon,
  Download as DownloadIcon,
  ExpandMore as ExpandMoreIcon,
  Code as CodeIcon,
  Link as LinkIcon,
  History as HistoryIcon,
  ChevronLeft as ChevronLeftIcon,
  ChevronRight as ChevronRightIcon,
  Add as AddIcon,
  Refresh as RefreshIcon,
  Delete as DeleteIcon,
  DeleteOutline as DeleteOutlineIcon,
} from '@mui/icons-material';
import { DataGrid } from '@mui/x-data-grid';
import { apiService } from '../services/api';

const SimpleChatInterface = () => {
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [loading, setLoading] = useState(false);
  const [historyOpen, setHistoryOpen] = useState(false);
  const [conversationId, setConversationId] = useState(null);
  const [conversations, setConversations] = useState([]);
  const [loadingConversations, setLoadingConversations] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const messagesEndRef = useRef(null);
  const initializationRef = useRef(false);
  const userId = 'default'; // In production, get from auth context

  // Scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Initialize on mount
  useEffect(() => {
    console.log('useEffect triggered, current initialization state:', initializationRef.current);
    // Prevent double initialization in React StrictMode
    if (initializationRef.current) {
      console.log('Skipping initialization - already initialized');
      return;
    }
    initializationRef.current = true;
    console.log('Starting initialization');
    
    const initializeChat = async () => {
      try {
        // First load existing conversations
        console.log('Loading conversations...');
        await loadConversations();
        
        // Only create a new conversation if we don't have one already
        if (!conversationId) {
          console.log('No conversation ID found, creating new conversation...');
          await createNewConversation(false);
        } else {
          console.log('Conversation ID exists:', conversationId);
        }
      } catch (error) {
        console.error('Initialization error:', error);
      }
    };
    
    initializeChat();
    
    // Cleanup function - reset the ref when component unmounts
    return () => {
      console.log('Cleanup - resetting initialization ref');
      initializationRef.current = false;
    };
  }, []);

  // Load conversations from MongoDB
  const loadConversations = async () => {
    setLoadingConversations(true);
    try {
      const response = await apiService.listConversations(userId);
      setConversations(response.data.conversations || []);
    } catch (error) {
      console.error('Failed to load conversations:', error);
    } finally {
      setLoadingConversations(false);
    }
  };

  // Create a new conversation
  const createNewConversation = async (shouldReloadList = true) => {
    try {
      console.log('Creating conversation on backend...');
      const response = await apiService.createConversation(userId);
      const newConvId = response.data.conversation_id;
      console.log('Created conversation:', newConvId);
      setConversationId(newConvId);
      
      // Set welcome message
      setMessages([{
        id: Date.now(),
        type: 'assistant',
        content: 'Hello! I can help you query your data. Try asking something like "Show me top 5 GL accounts by total amount". I\'ll maintain context throughout our conversation, so you can ask follow-up questions like "filter by amount > 1000".',
        timestamp: new Date(),
      }]);
      
      // Reload conversations list only if requested
      if (shouldReloadList) {
        console.log('Reloading conversations list...');
        await loadConversations();
      }
    } catch (error) {
      console.error('Failed to create conversation:', error);
      // Fallback to local conversation ID
      setConversationId(`conv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`);
    }
  };

  // Load a specific conversation
  const loadConversation = async (convId) => {
    try {
      const response = await apiService.getConversation(convId);
      const conversation = response.data;
      
      // Convert messages to the format expected by the UI
      const formattedMessages = conversation.messages.map(msg => ({
        id: msg.id,
        type: msg.type,
        content: msg.content,
        sql: msg.sql,
        results: msg.results,
        resultCount: msg.result_count,
        error: msg.error,
        metadata: msg.metadata,
        timestamp: new Date(msg.timestamp),
      }));
      
      setMessages(formattedMessages);
      setConversationId(convId);
      // Don't close the sidebar when selecting a conversation
    } catch (error) {
      console.error('Failed to load conversation:', error);
    }
  };

  const handleSendMessage = async () => {
    if (!inputMessage.trim() || loading) return;

    const userMessage = {
      id: Date.now(),
      type: 'user',
      content: inputMessage,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setLoading(true);

    try {
      // Call API with conversation ID
      console.log('Sending query:', inputMessage, 'with conversation ID:', conversationId);
      const response = await apiService.executeQuery(inputMessage, { conversationId });
      const { data } = response;
      
      console.log('API Response:', data);

      // Create assistant message with results
      const assistantMessage = {
        id: Date.now() + 1,
        type: 'assistant',
        content: data.explanation || 'Query executed successfully.',
        sql: data.sql,
        results: data.execution?.results || [],
        resultCount: data.execution?.row_count || 0,
        metadata: {
          cost: data.validation?.estimated_cost_usd,
          bytesProcessed: data.validation?.total_bytes_processed,
          tablesUsed: data.tables_used,
        },
        timestamp: new Date(),
      };

      console.log('Assistant message with results:', assistantMessage.results);
      setMessages(prev => [...prev, assistantMessage]);

    } catch (error) {
      console.error('Query error:', error);
      const errorMessage = {
        id: Date.now() + 1,
        type: 'assistant',
        content: 'Sorry, I encountered an error processing your query.',
        error: error.response?.data?.detail || error.message,
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };

  const downloadCSV = (results) => {
    if (!results || results.length === 0) return;
    
    const headers = Object.keys(results[0]);
    const csv = [
      headers.join(','),
      ...results.map(row => headers.map(h => JSON.stringify(row[h] || '')).join(','))
    ].join('\n');
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `query_results_${new Date().toISOString()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleNewChat = async () => {
    setInputMessage('');
    await createNewConversation();
    setHistoryOpen(false);
  };

  // Delete a conversation
  const handleDeleteConversation = async (convId) => {
    try {
      await apiService.deleteConversation(convId);
      await loadConversations();
      
      // If we deleted the current conversation, create a new one
      if (convId === conversationId) {
        await createNewConversation();
      }
    } catch (error) {
      console.error('Failed to delete conversation:', error);
    }
  };

  // Clear all conversations
  const handleClearAllConversations = async () => {
    if (!window.confirm('Are you sure you want to clear all conversations? This cannot be undone.')) {
      return;
    }
    
    try {
      // Delete all conversations
      for (const conv of conversations) {
        await apiService.deleteConversation(conv.conversationId);
      }
      
      // Clear local state and create new conversation
      setConversations([]);
      setMessages([]);
      await createNewConversation();
    } catch (error) {
      console.error('Failed to clear conversations:', error);
    }
  };

  const renderMessage = (message) => {
    if (message.type === 'user') {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
          <Stack direction="row" spacing={2} alignItems="flex-start" sx={{ maxWidth: '70%' }}>
            <Paper elevation={1} sx={{ p: 2, bgcolor: 'primary.main', color: 'white' }}>
              <Typography variant="body1">{message.content}</Typography>
              <Typography variant="caption" sx={{ display: 'block', mt: 1, opacity: 0.8 }}>
                {message.timestamp.toLocaleTimeString()}
              </Typography>
            </Paper>
            <Avatar sx={{ bgcolor: 'grey.500' }}>
              <PersonIcon />
            </Avatar>
          </Stack>
        </Box>
      );
    }

    // Assistant message
    return (
      <Box sx={{ mb: 3 }}>
        <Stack direction="row" spacing={2} alignItems="flex-start">
          <Avatar sx={{ bgcolor: 'primary.main' }}>
            <AIIcon />
          </Avatar>
          <Box sx={{ flex: 1, maxWidth: 'calc(100% - 60px)' }}>
            {/* Main message */}
            <Paper elevation={0} sx={{ p: 2, bgcolor: 'grey.100', mb: 2 }}>
              <Typography variant="body1">{message.content}</Typography>
              {message.error && (
                <Alert severity="error" sx={{ mt: 2 }}>
                  {message.error}
                </Alert>
              )}
              <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mt: 1 }}>
                {message.timestamp.toLocaleTimeString()}
              </Typography>
            </Paper>

            {/* SQL Query Display - Collapsible */}
            {message.sql && (
              <Accordion sx={{ mb: 2, bgcolor: 'grey.100' }}>
                <AccordionSummary
                  expandIcon={<ExpandMoreIcon />}
                  aria-controls="sql-content"
                  id="sql-header"
                >
                  <Stack direction="row" spacing={1} alignItems="center">
                    <CodeIcon fontSize="small" color="action" />
                    <Typography variant="subtitle2">View Generated SQL</Typography>
                  </Stack>
                </AccordionSummary>
                <AccordionDetails sx={{ bgcolor: 'grey.900', p: 2 }}>
                  <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 1 }}>
                    <Typography variant="caption" color="white">SQL Query</Typography>
                    <IconButton size="small" onClick={() => copyToClipboard(message.sql)}>
                      <CopyIcon sx={{ color: 'white', fontSize: 18 }} />
                    </IconButton>
                  </Stack>
                  <Box sx={{ 
                    fontFamily: 'monospace', 
                    fontSize: '0.875rem',
                    color: 'white',
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                  }}>
                    {message.sql}
                  </Box>
                </AccordionDetails>
              </Accordion>
            )}

            {/* Results Table */}
            {message.results && message.results.length > 0 && (
              <Paper elevation={1} sx={{ p: 2 }}>
                <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 1 }}>
                  <Typography variant="h6">
                    Results ({message.results.length} rows)
                  </Typography>
                  <Button
                    size="small"
                    startIcon={<DownloadIcon />}
                    onClick={() => downloadCSV(message.results)}
                  >
                    Export CSV
                  </Button>
                </Stack>
                
                <Box sx={{ height: 400, width: '100%' }}>
                  <DataGrid
                    rows={message.results.map((row, index) => ({ id: index, ...row }))}
                    columns={Object.keys(message.results[0]).map((key, index) => {
                      const isNumeric = typeof message.results[0][key] === 'number';
                      const isAmount = key.toLowerCase().includes('amount') || 
                                     key.toLowerCase().includes('total') ||
                                     key.toLowerCase().includes('revenue') ||
                                     key.toLowerCase().includes('cost');
                      const isFirstColumn = index === 0;
                      
                      return {
                        field: key,
                        headerName: key
                          .split('_')
                          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                          .join(' '),
                        flex: 1,
                        minWidth: 150,
                        type: isNumeric ? 'number' : 'string',
                        align: isFirstColumn ? 'left' : (isNumeric ? 'right' : 'left'),
                        headerAlign: isFirstColumn ? 'left' : (isNumeric ? 'right' : 'left'),
                        renderCell: (params) => {
                          if (isNumeric && isAmount) {
                            return `$${params.value.toLocaleString('en-US', { 
                              minimumFractionDigits: 2, 
                              maximumFractionDigits: 2 
                            })}`;
                          }
                          if (isNumeric) {
                            return params.value.toLocaleString('en-US');
                          }
                          return params.value;
                        }
                      };
                    })}
                    initialState={{
                      pagination: {
                        paginationModel: { pageSize: 10, page: 0 },
                      },
                    }}
                    pageSizeOptions={[10, 25, 50]}
                    density="compact"
                    disableRowSelectionOnClick
                    sx={{
                      '& .MuiDataGrid-cell': {
                        fontSize: '0.875rem',
                      },
                      '& .MuiDataGrid-columnHeaders': {
                        backgroundColor: 'action.hover',
                        fontSize: '0.875rem',
                        fontWeight: 600,
                      },
                    }}
                  />
                </Box>

                {/* Metadata - Compact */}
                {message.metadata && (message.metadata.cost || message.metadata.bytesProcessed) && (
                  <Stack direction="row" spacing={1} sx={{ mt: 1 }}>
                    {message.metadata.cost && (
                      <Chip
                        size="small"
                        label={`Cost: $${message.metadata.cost.toFixed(6)}`}
                        variant="outlined"
                        sx={{ height: 24, fontSize: '0.75rem' }}
                      />
                    )}
                    {message.metadata.bytesProcessed && (
                      <Chip
                        size="small"
                        label={`${(message.metadata.bytesProcessed / 1024 / 1024).toFixed(1)} MB`}
                        variant="outlined"
                        sx={{ height: 24, fontSize: '0.75rem' }}
                      />
                    )}
                  </Stack>
                )}
              </Paper>
            )}

            {/* No results message */}
            {message.results && message.results.length === 0 && message.sql && (
              <Paper elevation={1} sx={{ p: 2, bgcolor: 'warning.light' }}>
                <Typography variant="body2">
                  The query executed successfully but returned no results.
                </Typography>
              </Paper>
            )}
          </Box>
        </Stack>
      </Box>
    );
  };

  const renderHistoryPanel = () => (
    <Box
      sx={{
        position: 'absolute',
        right: 0,
        top: 0,
        bottom: 0,
        width: historyOpen ? 320 : 48,
        transition: 'width 0.3s ease-in-out',
        zIndex: 100,
        display: 'flex',
        flexDirection: 'column',
      }}
    >
      <Paper
        elevation={3}
        sx={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          borderRadius: 0,
          overflow: 'hidden',
        }}
    >
      {/* Toggle Button */}
      <Box
        sx={{
          p: 1,
          borderBottom: 1,
          borderColor: 'divider',
          display: 'flex',
          alignItems: 'center',
          justifyContent: historyOpen ? 'space-between' : 'center',
          cursor: 'pointer',
          bgcolor: 'grey.100',
          '&:hover': {
            bgcolor: 'grey.200',
          },
        }}
        onClick={() => setHistoryOpen(!historyOpen)}
      >
        {historyOpen ? (
          <>
            <Stack direction="row" spacing={1} alignItems="center">
              <HistoryIcon color="action" />
              <Typography variant="subtitle2" fontWeight="bold">
                Conversation History
              </Typography>
            </Stack>
            <IconButton size="small">
              <ChevronRightIcon />
            </IconButton>
          </>
        ) : (
          <IconButton size="small">
            <ChevronLeftIcon />
          </IconButton>
        )}
      </Box>

      {/* History Content */}
      {historyOpen && (
        <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
          {/* Search Bar */}
          <Box sx={{ p: 2, pb: 1 }}>
            <TextField
              fullWidth
              size="small"
              placeholder="Search conversations..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                },
              }}
            />
          </Box>
          
          {/* Conversations List */}
          <Box sx={{ 
            flex: 1, 
            overflow: 'auto', 
            p: 2, 
            pt: 1,
            '&::-webkit-scrollbar': {
              width: '6px',
            },
            '&::-webkit-scrollbar-track': {
              backgroundColor: 'rgba(0, 0, 0, 0.05)',
              borderRadius: '3px',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '3px',
              '&:hover': {
                backgroundColor: 'rgba(0, 0, 0, 0.4)',
              },
            },
          }}>
          {loadingConversations ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
              <CircularProgress size={24} />
            </Box>
          ) : conversations.length === 0 ? (
            <Typography variant="body2" color="text.secondary" align="center">
              No conversations yet
            </Typography>
          ) : (
            <Stack spacing={1}>
              {conversations
                .filter(conv => {
                  if (!searchQuery) return true;
                  const query = searchQuery.toLowerCase();
                  return (
                    conv.title.toLowerCase().includes(query) ||
                    conv.messages.some(msg => msg.content.toLowerCase().includes(query))
                  );
                })
                .map((conv) => {
                const isActive = conv.conversationId === conversationId;
                const firstUserMessage = conv.messages.find(m => m.type === 'user');
                const messageCount = conv.messages.filter(m => m.type === 'user').length;
                
                // Generate display title from first user message, similar to ChatGPT
                const displayTitle = firstUserMessage 
                  ? firstUserMessage.content.length > 50 
                    ? firstUserMessage.content.substring(0, 50) + '...'
                    : firstUserMessage.content
                  : 'New Conversation';
                
                return (
                  <Paper
                    key={conv.conversationId}
                    elevation={0}
                    sx={{
                      p: 1.5,
                      bgcolor: isActive ? 'primary.light' : 'grey.100',
                      cursor: 'pointer',
                      border: isActive ? '2px solid' : '1px solid',
                      borderColor: isActive ? 'primary.main' : 'divider',
                      '&:hover': {
                        bgcolor: isActive ? 'primary.light' : 'grey.200',
                      },
                    }}
                    onClick={() => loadConversation(conv.conversationId)}
                  >
                    <Stack spacing={0.5}>
                      <Typography 
                        variant="subtitle2" 
                        fontWeight={isActive ? 'bold' : 'medium'}
                        sx={{ 
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          whiteSpace: 'nowrap',
                        }}
                      >
                        {displayTitle}
                      </Typography>
                      
                      <Stack direction="row" spacing={1} alignItems="center">
                        <Typography variant="caption" color="text.secondary">
                          {new Date(conv.updatedAt).toLocaleDateString()}
                        </Typography>
                        {messageCount > 0 && (
                          <Chip
                            size="small"
                            label={`${messageCount}`}
                            sx={{ height: 18, fontSize: '0.7rem' }}
                          />
                        )}
                      </Stack>
                    </Stack>
                  </Paper>
                );
              })}
            </Stack>
          )}
          </Box>
          
          {/* Clear All Button at bottom */}
          {conversations.length > 0 && (
            <Box sx={{ p: 2, pt: 1, borderTop: 1, borderColor: 'divider' }}>
              <Button
                fullWidth
                size="small"
                startIcon={<DeleteOutlineIcon />}
                onClick={handleClearAllConversations}
                sx={{
                  color: 'text.secondary',
                  borderColor: 'divider',
                  '&:hover': {
                    borderColor: 'action.hover',
                    bgcolor: 'action.hover',
                  },
                }}
                variant="outlined"
              >
                Clear All
              </Button>
            </Box>
          )}
        </Box>
      )}
      </Paper>
    </Box>
  );

  return (
    <Box sx={{ height: '100vh', display: 'flex', position: 'relative', overflow: 'hidden' }}>
      {/* Main Content Area */}
      <Box sx={{ 
        flex: 1, 
        display: 'flex',
        flexDirection: 'column',
        height: '100vh',
        overflow: 'hidden',
        mr: historyOpen ? '320px' : '48px',
        transition: 'margin-right 0.3s ease-in-out',
      }}>
        {/* Header */}
        <Paper elevation={1} sx={{ p: 2, borderRadius: 0, position: 'relative', zIndex: 10, flexShrink: 0 }}>
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            {/* Left section */}
            <Box>
              <Typography variant="h5" fontWeight="bold">
                Analytics Companion
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
                Ask questions about your data in natural language
              </Typography>
            </Box>
            
            {/* Right section */}
            <Box>
              <Stack direction="row" spacing={2} alignItems="center">
                <Button
                  variant="contained"
                  startIcon={<AddIcon />}
                  onClick={handleNewChat}
                  size="small"
                  sx={{ 
                    borderRadius: 1,
                    textTransform: 'none',
                    px: 2,
                    py: 0.75,
                  }}
                >
                  New Chat
                </Button>
                
                <Divider orientation="vertical" flexItem />
                
                <Chip
                  icon={<LinkIcon />}
                  label="Context Enabled"
                  color="primary"
                  size="small"
                  variant="outlined"
                />
                
                <Chip
                  icon={<HistoryIcon />}
                  label={`${conversations.length} conversations`}
                  size="small"
                  variant="outlined"
                  onClick={() => setHistoryOpen(!historyOpen)}
                  sx={{ cursor: 'pointer' }}
                />
              </Stack>
            </Box>
          </Box>
        </Paper>

        {/* Messages Area - Scrollable */}
        <Box sx={{ 
          flex: 1, 
          overflow: 'auto', 
          p: 3,
          bgcolor: 'background.default',
          minHeight: 0, // Important for flex overflow
          '&::-webkit-scrollbar': {
            width: '12px',
          },
          '&::-webkit-scrollbar-track': {
            backgroundColor: '#f1f1f1',
            borderRadius: '6px',
            margin: '4px',
          },
          '&::-webkit-scrollbar-thumb': {
            backgroundColor: '#c1c1c1',
            borderRadius: '6px',
            border: '2px solid #f1f1f1',
            '&:hover': {
              backgroundColor: '#a8a8a8',
            },
            '&:active': {
              backgroundColor: '#999999',
            },
          },
          '&::-webkit-scrollbar-corner': {
            backgroundColor: '#f1f1f1',
          },
        }}>
          <Box sx={{ maxWidth: 1200, mx: 'auto' }}>
            {messages.map(message => (
              <div key={message.id} id={`message-${message.id}`}>
                {renderMessage(message)}
              </div>
            ))}
            
            {loading && (
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Avatar sx={{ bgcolor: 'primary.main' }}>
                  <AIIcon />
                </Avatar>
                <Box>
                  <CircularProgress size={20} />
                  <Typography variant="body2" color="text.secondary" sx={{ ml: 2 }}>
                    Processing your query...
                  </Typography>
                </Box>
              </Box>
            )}
            
            <div ref={messagesEndRef} />
          </Box>
        </Box>

        <Divider sx={{ flexShrink: 0 }} />

        {/* Input Area - Fixed */}
        <Paper elevation={3} sx={{ p: 3, borderRadius: 0, flexShrink: 0 }}>
          <Box sx={{ maxWidth: 1200, mx: 'auto' }}>
            <Stack direction="row" spacing={2}>
              <TextField
                fullWidth
                value={inputMessage}
                onChange={(e) => setInputMessage(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder="Ask a question about your data..."
                disabled={loading}
                variant="outlined"
                sx={{
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  }
                }}
              />
              <Button
                variant="contained"
                onClick={handleSendMessage}
                disabled={!inputMessage.trim() || loading}
                sx={{ 
                  borderRadius: 2, 
                  px: 3,
                  minWidth: 100
                }}
                endIcon={<SendIcon />}
              >
                Send
              </Button>
            </Stack>

            {/* Sample queries */}
            <Stack direction="row" spacing={1} sx={{ mt: 2 }} flexWrap="wrap">
              <Typography variant="caption" color="text.secondary">
                Try:
              </Typography>
              {[
                "Show me top 5 GL accounts by total amount",
                "What's the total revenue by month?",
                "List all transactions above $10,000"
              ].map((query, idx) => (
                <Chip
                  key={idx}
                  label={query}
                  size="small"
                  onClick={() => setInputMessage(query)}
                  sx={{ 
                    cursor: 'pointer',
                    mb: 1,
                    '&:hover': {
                      bgcolor: 'primary.light',
                      color: 'primary.contrastText',
                    }
                  }}
                />
              ))}
            </Stack>
          </Box>
        </Paper>
      </Box>
      
      {/* History Panel - Fixed Sidebar */}
      {renderHistoryPanel()}
    </Box>
  );
};

export default SimpleChatInterface;